<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <link rel="icon" type="image/png" href="../favicon.ico">
    <title>Features</title>
    
    

    
    <link rel="stylesheet" href="../style.min.css">

    

    <meta name="generator" content="Hugo 0.68.3" />
</head>
<body>

<div class="columns container is-marginless">
    <div id="sidebar" class="column is-one-quarter">
        <div class="brand">
    <a href="https://mitmproxy.org/">
        <img src='../logo-docs.png' alt="mitmproxy docs"/>
    </a>

</div>
<nav class="menu">
    <p class="menu-label">Overview</p>
    <ul class="menu-list">
    
    
    
    
        <li >
            <a class=""
                href="../">Introduction</a>
        </li>
    
        <li >
            <a class=""
                href="../overview-installation/">Installation</a>
        </li>
    
        <li >
            <a class=""
                href="../overview-getting-started/">Getting Started</a>
        </li>
    
</ul>

    <p class="menu-label">Beginner Tutorial</p>
    <ul class="menu-list">
    
    
    
    
        <li >
            <a class=""
                href="../mitmproxytutorial-userinterface/">User Interface</a>
        </li>
    
        <li >
            <a class=""
                href="../mitmproxytutorial-interceptrequests/">Intercept Requests</a>
        </li>
    
        <li >
            <a class=""
                href="../mitmproxytutorial-modifyrequests/">Modify Requests</a>
        </li>
    
        <li >
            <a class=""
                href="../mitmproxytutorial-replayrequests/">Replay Requests</a>
        </li>
    
        <li >
            <a class=""
                href="../mitmproxytutorial-whatsnext/">What&#39;s Next</a>
        </li>
    
</ul>

    <p class="menu-label">Core concepts</p>
    <ul class="menu-list">
    
    
    
    
        <li >
            <a class=""
                href="../concepts-howmitmproxyworks/">How mitmproxy works</a>
        </li>
    
        <li >
            <a class=""
                href="../concepts-modes/">Modes of operation</a>
        </li>
    
        <li >
            <a class=""
                href="../concepts-certificates/">Certificates</a>
        </li>
    
        <li >
            <a class="is-active"
                href="../overview-features/">Features</a>
        </li>
    
        <li >
            <a class=""
                href="../concepts-filters/">Filter expressions</a>
        </li>
    
        <li >
            <a class=""
                href="../concepts-options/">Options</a>
        </li>
    
        <li >
            <a class=""
                href="../concepts-commands/">Commands</a>
        </li>
    
        <li >
            <a class=""
                href="../concepts-protocols/">Protocols</a>
        </li>
    
</ul>

    <p class="menu-label"> Addon Development </p>
    <ul class="menu-list">
    
    
    
    
        <li >
            <a class=""
                href="../addons-overview/">Addons</a>
        </li>
    
        <li >
            <a class=""
                href="../addons-events/">Events</a>
        </li>
    
        <li >
            <a class=""
                href="../addons-options/">Options</a>
        </li>
    
        <li >
            <a class=""
                href="../addons-commands/">Commands</a>
        </li>
    
        <li >
            <a class=""
                href="../addons-scripting/">Scripting</a>
        </li>
    
        <li >
            <a class=""
                href="../addons-examples/">Example Addons</a>
        </li>
    
</ul>

    <p class="menu-label"> HOWTOs </p>
    <ul class="menu-list">
    
    
    
    
        <li >
            <a class=""
                href="../howto-kubernetes/">Kubernetes Services</a>
        </li>
    
        <li >
            <a class=""
                href="../howto-transparent/">Transparent Proxying</a>
        </li>
    
        <li >
            <a class=""
                href="../howto-wireshark-tls/">Wireshark and SSL/TLS</a>
        </li>
    
        <li >
            <a class=""
                href="../howto-ignoredomains/">Ignoring Domains</a>
        </li>
    
        <li >
            <a class=""
                href="../howto-transparent-vms/">Transparently Proxying VMs</a>
        </li>
    
        <li >
            <a class=""
                href="../howto-install-system-trusted-ca-android/">Install System CA on Android</a>
        </li>
    
</ul>

    <p class="menu-label"> Tutorials </p>
    <ul class="menu-list">
    
    
    
    
        <li >
            <a class=""
                href="../tute-clientreplay/">Client replay</a>
        </li>
    
        <li >
            <a class=""
                href="../tute-highscores/">Setting highscores on Apple GameCenter</a>
        </li>
    
</ul>
</nav>

    </div>
    <div id="main" class="column content">
        
        
<a class="button is-small is-outlined is-link is-pulled-right"
   target="_blank"
   href="https://github.com/mitmproxy/mitmproxy/blob/master/docs/src/content/overview-features.md"
>
    Edit on GitHub
</a>



        <h1 id="features"><a class="anchor" href="#features">#&nbsp;&nbsp;</a>Features</h1>
<ul>
<li><a href="#anticache">Anticache</a></li>
<li><a href="#client-side-replay">Client-side replay</a></li>
<li><a href="#map-local">Map Local</a></li>
<li><a href="#map-remote">Map Remote</a></li>
<li><a href="#modify-body">Modify Body</a></li>
<li><a href="#modify-headers">Modify Headers</a></li>
<li><a href="#proxy-authentication">Proxy Authentication</a></li>
<li><a href="#server-side-replay">Server-side replay</a></li>
<li><a href="#sticky-auth">Sticky Auth</a></li>
<li><a href="#sticky-cookies">Sticky Cookies</a></li>
<li><a href="#streaming">Streaming</a></li>
<li><a href="#upstream-certificates">Upstream Certificates</a></li>
</ul>
<h2 id="anticache"><a class="anchor" href="#anticache">#&nbsp;&nbsp;</a>Anticache</h2>
<p>When the <code>anticache</code> option is set, it removes headers (<code>if-none-match</code> and
<code>if-modified-since</code>) that might elicit a <code>304 not modified</code> response from the
server. This is useful when you want to make sure you capture an HTTP exchange
in its totality. It&rsquo;s also often used during client-side replay, when you want
to make sure the server responds with complete data.</p>
<h2 id="client-side-replay"><a class="anchor" href="#client-side-replay">#&nbsp;&nbsp;</a>Client-side replay</h2>
<p>Client-side replay does what it says on the tin: you provide a previously saved
HTTP conversation, and mitmproxy replays the client requests one by one. Note
that mitmproxy serialises the requests, waiting for a response from the server
before starting the next request. This might differ from the recorded
conversation, where requests may have been made concurrently.</p>
<p>You may want to use client-side replay in conjunction with the <code>anticache</code>
option, to make sure the server responds with complete data.</p>
<h2 id="map-local"><a class="anchor" href="#map-local">#&nbsp;&nbsp;</a>Map Local</h2>
<p>The <code>map_local</code> option lets you specify an arbitrary number of patterns that
define redirections of HTTP requests to local files or directories.
The local file is fetched instead of the original resource
and transparently returned to the client.</p>
<p><code>map_local</code> patterns look like this:</p>
<pre><code>|url-regex|local-path
|flow-filter|url-regex|local-path
</code></pre><ul>
<li>
<p><strong>local-path</strong> is the file or directory that should be served to the client.</p>
</li>
<li>
<p><strong>url-regex</strong> is a regular expression applied on the request URL. It must match for a redirect to take place.</p>
</li>
<li>
<p><strong>flow-filter</strong> is an optional mitmproxy <a href="../concepts-filters/">filter expression</a>
that additionally constrains which requests will be redirected.</p>
</li>
</ul>
<h3 id="examples"><a class="anchor" href="#examples">#&nbsp;&nbsp;</a>Examples</h3>
<table>
<thead>
<tr>
<th>Pattern</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>|example.com/main.js|~/main-local.js</code></td>
<td>Replace <code>example.com/main.js</code> with <code>~/main-local.js</code>.</td>
</tr>
<tr>
<td><code>|example.com/static|~/static</code></td>
<td>Replace <code>example.com/static/foo/bar.css</code> with <code>~/static/foo/bar.css</code>.</td>
</tr>
<tr>
<td><code>|example.com/static/foo|~/static</code></td>
<td>Replace <code>example.com/static/foo/bar.css</code> with <code>~/static/bar.css</code>.</td>
</tr>
<tr>
<td><code>|~m GET|example.com/static|~/static</code></td>
<td>Replace <code>example.com/static/foo/bar.css</code> with <code>~/static/foo/bar.css</code> (but only for GET requests).</td>
</tr>
</tbody>
</table>
<h3 id="details"><a class="anchor" href="#details">#&nbsp;&nbsp;</a>Details</h3>
<p>If <em>local-path</em> is a file, this file will always be served. File changes will be reflected immediately, there is no caching.</p>
<p>If <em>local-path</em> is a directory, <em>url-regex</em> is used to split the request URL in two parts and part on the right is appended to <em>local-path</em>, excluding the query string.
However, if <em>url-regex</em> contains a regex capturing group, this behavior changes and the first capturing group is appended instead (and query strings are not stripped).
Special characters are mapped to <code>_</code>. If the file cannot be found, <code>/index.html</code> is appended and we try again. Directory traversal outside of the originally specified directory is not possible.</p>
<p>To illustrate this, consider the following example which maps all requests for <code>example.org/css*</code> to the local directory <code>~/static-css</code>.</p>
<pre>
                  ┌── url regex ──┬─ local path ─┐
map_local option: |<span style="color:#f92672">example.com/css</span>|<span style="color:#82b719">~/static-css</span>
                   <!--                     -->         │
                   <!--                     -->         │    URL is split here
                   <!--                     -->         ▼            ▼
HTTP Request URL: https://<span style="color:#f92672">example.com/css</span><span style="color:#66d9ef">/print/main.css</span><span style="color:#bbb">?timestamp=123</span>
                          <!--                     -->               <!--                            -->      │        <!--                         -->        ▼
                          <!--                     -->               <!--                            -->      ▼        <!--                         -->      query string is ignored
Served File:      Preferred: <span style="color:#82b719">~/static-css</span><span style="color:#66d9ef">/print/main.css</span>
                   Fallback: <span style="color:#82b719">~/static-css</span><span style="color:#66d9ef">/print/main.css</span>/index.html
                  Otherwise: 404 response without content
</pre>
<p>If the file depends on the query string, we can use regex capturing groups. In this example, all <code>GET</code> requests for
<code>example.org/index.php?page=&lt;page-name&gt;</code> are mapped to <code>~/static-dir/&lt;page-name&gt;</code>:</p>
<pre>
                    flow
                  ┌filter┬─────────── url regex ───────────┬─ local path ─┐
map_local option: |~m GET|<span style="color:#f92672">example.com/index.php\\?page=</span><span style="color:#66d9ef">(.+)</span>|<span style="color:#82b719">~/static-dir</span>
                          <!--                     -->  │                          <!--                            --> │
                          <!--                     -->  │                          <!--                            --> │ regex group = suffix
                          <!--                     -->  ▼                          <!--                            --> ▼
HTTP Request URL: https://<span style="color:#f92672">example.com/index.php?page=</span><span style="color:#66d9ef">aboutus</span></span>
                          <!--                     -->                           <!--                            -->   │
                          <!--                     -->                           <!--                            -->   ▼
Served File:                 Preferred: <span style="color:#82b719">~/static-dir</span>/<span style="color:#66d9ef">aboutus</span>
                              Fallback: <span style="color:#82b719">~/static-dir</span>/<span style="color:#66d9ef">aboutus</span>/index.html
                             Otherwise: 404 response without content
</pre>
<h2 id="map-remote"><a class="anchor" href="#map-remote">#&nbsp;&nbsp;</a>Map Remote</h2>
<p>The <code>map_remote</code> option lets you specify an arbitrary number of patterns that
define replacements within HTTP request URLs before they are sent to a server.
The substituted URL is fetched instead of the original resource
and the corresponding HTTP response is returned transparently to the client.
Note that if the original destination uses HTTP2, the substituted destination
needs to support HTTP2 as well, otherwise the substituted request may fail.
As a workaround you can start mitmproxy with the <code>--no-http2</code> flag to disable HTTP2.
<code>map_remote</code> patterns look like this:</p>
<pre><code>|flow-filter|url-regex|replacement
|url-regex|replacement
</code></pre><ul>
<li>
<p><strong>flow-filter</strong> is an optional mitmproxy <a href="../concepts-filters/">filter expression</a>
that defines which requests the <code>map_remote</code> option applies to.</p>
</li>
<li>
<p><strong>url-regex</strong> is a valid Python regular expression that defines what gets replaced in the URLs of requests.</p>
</li>
<li>
<p><strong>replacement</strong> is a string literal that is substituted in.</p>
</li>
</ul>
<p>The <em>separator</em> is arbitrary, and is defined by the first character.</p>
<h3 id="examples-1"><a class="anchor" href="#examples-1">#&nbsp;&nbsp;</a>Examples</h3>
<p>Map all requests ending with <code>.jpg</code> to <code>https://placedog.net/640/480?random</code>.
Note that this might fail if the original HTTP request destination uses HTTP2 but the replaced
destination does not support HTTP2.</p>
<pre><code>|.*\.jpg$|https://placedog.net/640/480?random
</code></pre><p>Re-route all GET requests from <code>example.org</code> to <code>mitmproxy.org</code> (using <code>|</code> as the separator):</p>
<pre><code>|~m GET|//example.org/|//mitmproxy.org/
</code></pre><h2 id="modify-body"><a class="anchor" href="#modify-body">#&nbsp;&nbsp;</a>Modify Body</h2>
<p>The <code>modify_body</code> option lets you specify an arbitrary number of patterns that
define replacements within bodies of flows. <code>modify_body</code> patterns look like this:</p>
<pre><code>/flow-filter/body-regex/replacement
/flow-filter/body-regex/@file-path
/body-regex/replacement
/body-regex/@file-path
</code></pre><ul>
<li>
<p><strong>flow-filter</strong> is an optional mitmproxy <a href="../concepts-filters/">filter expression</a>
that defines which flows a replacement applies to.</p>
</li>
<li>
<p><strong>body-regex</strong> is a valid Python regular expression that defines what gets replaced.</p>
</li>
<li>
<p><strong>replacement</strong> is a string literal that is substituted in. If the replacement string
literal starts with <code>@</code> as in <code>@file-path</code>, it is treated as a <strong>file path</strong> from which the replacement is read.</p>
</li>
</ul>
<p>The <em>separator</em> is arbitrary, and is defined by the first character.</p>
<p>Modify hooks fire when either a client request or a server response is
received. Only the matching flow component is affected: so, for example,
if a modify hook is triggered on server response, the replacement is
only run on the Response object leaving the Request intact. You control
whether the hook triggers on the request, response or both using the
filter pattern. If you need finer-grained control than this, it&rsquo;s simple
to create a script using the replacement API on Flow components.</p>
<h3 id="examples-2"><a class="anchor" href="#examples-2">#&nbsp;&nbsp;</a>Examples</h3>
<p>Replace <code>foo</code> with <code>bar</code> in bodies of requests:</p>
<pre><code>/~q/foo/bar
</code></pre><p>Replace <code>foo</code> with the data read from <code>~/xss-exploit</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">mitmdump --modify-body :~q:foo:@~/xss-exploit
</code></pre></div><h2 id="modify-headers"><a class="anchor" href="#modify-headers">#&nbsp;&nbsp;</a>Modify Headers</h2>
<p>The <code>modify_headers</code> option lets you specify a set of headers to be modified.
New headers can be added, and existing headers can be overwritten or removed.
<code>modify_headers</code> patterns look like this:</p>
<pre><code>/flow-filter/name/value
/flow-filter/name/@file-path
/name/value
/name/@file-path
</code></pre><ul>
<li>
<p><strong>flow-filter</strong> is an optional mitmproxy <a href="../concepts-filters/">filter expression</a>
that defines which flows to modify headers on.</p>
</li>
<li>
<p><strong>name</strong> is the header name to be set, replaced or removed.</p>
</li>
<li>
<p><strong>value</strong> is the header value to be set or replaced. An empty <strong>value</strong> removes existing
headers with <strong>name</strong>. If the value string literal starts with <code>@</code> as in
<code>@file-path</code>, it is treated as a <strong>file path</strong> from which the replacement is read.</p>
</li>
</ul>
<p>The <em>separator</em> is arbitrary, and is defined by the first character.</p>
<p>Existing headers are overwritten by default. This can be changed using a filter expression.</p>
<p>Modify hooks fire when either a client request or a server response is
received. Only the matching flow component is affected: so, for example,
if a modify hook is triggered on server response, the replacement is
only run on the Response object leaving the Request intact. You control
whether the hook triggers on the request, response or both using the
filter pattern. If you need finer-grained control than this, it&rsquo;s simple
to create a script using the replacement API on Flow components.</p>
<h3 id="examples-3"><a class="anchor" href="#examples-3">#&nbsp;&nbsp;</a>Examples</h3>
<p>Set the <code>Host</code> header to <code>example.org</code> for all requests (existing <code>Host</code>
headers are replaced):</p>
<pre><code>/~q/Host/example.org
</code></pre><p>Set the <code>Host</code> header to <code>example.org</code> for all requests that do not have an
existing <code>Host</code> header:</p>
<pre><code>/~q &amp; !~h Host:/Host/example.org
</code></pre><p>Set the <code>User-Agent</code> header to the data read from <code>~/useragent.txt</code> for all requests
(existing <code>User-Agent</code> headers are replaced):</p>
<pre><code>/~q/Host/@~/useragent.txt
</code></pre><p>Remove existing <code>Host</code> headers from all requests:</p>
<pre><code>/~q/Host/
</code></pre><h2 id="proxy-authentication"><a class="anchor" href="#proxy-authentication">#&nbsp;&nbsp;</a>Proxy Authentication</h2>
<p>Asks the user for authentication before they are permitted to use the proxy.
Authentication headers are stripped from the flows, so they are not passed to
upstream servers. For now, only HTTP Basic authentication is supported. The
proxy auth options are not compatible with the transparent, socks or reverse
proxy mode.</p>
<h2 id="server-side-replay"><a class="anchor" href="#server-side-replay">#&nbsp;&nbsp;</a>Server-side replay</h2>
<p>The <code>server_replay</code> option lets us replay server responses from saved HTTP
conversations. To do this, we use a set of heuristics to match incoming requests
with saved responses. By default, we exclude request headers when matching
incoming requests with responses from the replay file, and use only the URL and
request method for matching. This works in most circumstances, and makes it
possible to replay server responses in situations where request headers would
naturally vary, e.g. using a different user agent.</p>
<p>There is a slew of ways to customise the matching heuristic, including
specifying headers to include, request parameters to exclude, etc. These options
are collected under the <code>server_replay</code> prefix - please see the built-in
documentation for details.</p>
<h3 id="response-refreshing"><a class="anchor" href="#response-refreshing">#&nbsp;&nbsp;</a>Response refreshing</h3>
<p>Simply replaying server responses without modification will often result in
unexpected behaviour. For example cookie timeouts that were in the future at the
time a conversation was recorded might be in the past at the time it is
replayed. By default, mitmproxy refreshes server responses before sending them
to the client. The <strong>date</strong>, <strong>expires</strong> and <strong>last-modified</strong> headers are all
updated to have the same relative time offset as they had at the time of
recording. So, if they were in the past at the time of recording, they will be
in the past at the time of replay, and vice versa. Cookie expiry times are
updated in a similar way.</p>
<p>You can turn off this behaviour by setting the <code>server_replay_refresh</code> option to
<code>false</code>.</p>
<h3 id="replaying-a-session-recorded-in-reverse-proxy-mode"><a class="anchor" href="#replaying-a-session-recorded-in-reverse-proxy-mode">#&nbsp;&nbsp;</a>Replaying a session recorded in Reverse-proxy Mode</h3>
<p>If you have captured the session in reverse proxy mode, in order to replay it
you still have to specify the server URL, otherwise you may get the error: &lsquo;HTTP
protocol error in client request: Invalid HTTP request form (expected authority
or absolute&hellip;)'.</p>
<p>During replay, when the client&rsquo;s requests match previously recorded requests,
then the respective recorded responses are simply replayed by mitmproxy.
Otherwise, the unmatched requests is forwarded to the upstream server. If
forwarding is not desired, you can use the &ndash;kill (-k) switch to prevent that.</p>
<h2 id="sticky-auth"><a class="anchor" href="#sticky-auth">#&nbsp;&nbsp;</a>Sticky auth</h2>
<p>The <code>stickyauth</code> option is analogous to the sticky cookie option, in that HTTP
<strong>Authorization</strong> headers are simply replayed to the server once they have been
seen. This is enough to allow you to access a server resource using HTTP Basic
authentication through the proxy. Note that <span
data-role="program">mitmproxy</span> doesn&rsquo;t (yet) support replay of HTTP Digest
authentication.</p>
<h2 id="sticky-cookies"><a class="anchor" href="#sticky-cookies">#&nbsp;&nbsp;</a>Sticky cookies</h2>
<p>When the <code>stickycookie</code> option is set, <strong>mitmproxy</strong> will add the cookie most
recently set by the server to any cookie-less request. Consider a service that
sets a cookie to track the session after authentication. Using sticky cookies,
you can fire up mitmproxy, and authenticate to a service as you usually would
using a browser. After authentication, you can request authenticated resources
through mitmproxy as if they were unauthenticated, because mitmproxy will
automatically add the session tracking cookie to requests. Among other things,
this lets you script interactions with authenticated resources (using tools like
wget or curl) without having to worry about authentication.</p>
<p>Sticky cookies are especially powerful when used in conjunction with <a href="#client-side-replay">client
replay</a> - you can record the
authentication process once, and simply replay it on startup every time you need
to interact with the secured resources.</p>
<h2 id="streaming"><a class="anchor" href="#streaming">#&nbsp;&nbsp;</a>Streaming</h2>
<p>By default, mitmproxy will read an entire request/response, perform any
indicated manipulations on it, and then send the message on to the other party.
This can be problematic when downloading or uploading large files. When
streaming is enabled, message bodies are not buffered on the proxy but instead
sent directly to the server/client. HTTP headers are still fully buffered before
being sent.</p>
<p>Request/response streaming is enabled by specifying a size cutoff in the
<code>stream_large_bodies</code> option.</p>
<h3 id="customizing-streaming"><a class="anchor" href="#customizing-streaming">#&nbsp;&nbsp;</a>Customizing Streaming</h3>
<p>You can also use a script to customise exactly which requests or responses are
streamed. Requests/Responses that should be tagged for streaming by setting
their <code>.stream</code> attribute to <code>True</code>:</p>
<div class="example">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">Select which responses should be streamed.
</span><span style="color:#e6db74">
</span><span style="color:#e6db74">Enable response streaming for all HTTP flows.
</span><span style="color:#e6db74">This is equivalent to passing `--set stream_large_bodies=1` to mitmproxy.
</span><span style="color:#e6db74">&#34;&#34;&#34;</span>


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">responseheaders</span>(flow):
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Enables streaming for all responses.
</span><span style="color:#e6db74">    This is equivalent to passing `--set stream_large_bodies=1` to mitmproxy.
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    flow<span style="color:#f92672">.</span>response<span style="color:#f92672">.</span>stream <span style="color:#f92672">=</span> True</code></pre></div>
<div class="path">examples/addons/http-stream-simple.py</div>
</div>

<h3 id="websockets"><a class="anchor" href="#websockets">#&nbsp;&nbsp;</a>Websockets</h3>
<p>The <code>stream_websockets</code> option enables an analogous behaviour for websockets.
When WebSocket streaming is enabled, portions of the code which may perform
changes to the WebSocket message payloads will not have any effect on the actual
payload sent to the server as the frames are immediately forwarded to the
server. In contrast to HTTP streaming, where the body is not stored, the message
payload will still be stored in the WebSocket flow.</p>
<h2 id="upstream-certificates"><a class="anchor" href="#upstream-certificates">#&nbsp;&nbsp;</a>Upstream Certificates</h2>
<p>When mitmproxy receives a connection destined for an SSL-protected service, it
freezes the connection before reading its request data, and makes a connection
to the upstream server to &ldquo;sniff&rdquo; the contents of its SSL certificate. The
information gained - the <strong>Common Name</strong> and <strong>Subject Alternative Names</strong> - is
then used to generate the interception certificate, which is sent to the client
so the connection can continue.</p>
<p>This rather intricate little dance lets us seamlessly generate correct
certificates even if the client has specified only an IP address rather than the
hostname. It also means that we don&rsquo;t need to sniff additional data to generate
certs in transparent mode.</p>
<p>Upstream cert sniffing is on by default, and can optionally be turned off with
the <code>upstream_cert</code> option.</p>


    </div>
</div>
</body>
</html>

